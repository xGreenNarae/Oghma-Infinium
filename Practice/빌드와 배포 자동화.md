이것이 필요한 이유
  - 클라이언트 작업을 하는 사람이 분리되어 있는 경우, 작업 중인 서버의 최신 상태를 로컬이 아닌 원격에 두는 것이 편리하다.
  - `깃허브의 메인 브랜치 소스코드가 변경된 시점부터` 공개적으로 접근할 수 있는 `원격 서버의 코드를 갱신해주기 까지`의 작업을 자동화 하는 것.  
  
이 영역을 자동화 하는 방법은 내가 경험해 본것을 바탕으로 3가지 레벨로 나눌 수 있다.
  1. 수동작업:  로컬 터미널에서 클라우드에 접속하여, 레포지토리를 클론하고, 기존의 코드를 교체한 뒤, 서비스 중인 프로세스를 종료하고 새 것을 띄운다. 간단한 규모에서 능숙하더라도 3분 정도는 소요될 것이고 실수할 여지도 많다.
  2. 스크립트 작성: 클라우드 접속, 소스코드를 내려받고 교체하는 작업 등을 스크립트로 자동화한다. 빨라도 10초 정도는 소요된다.
  3. 깃허브에서 이벤트가 발생했을 시 자동으로 작업을 트리거해주는 기술을 지원한다. webhook, github actions 등 인데, 
      - 작업 당 10초 정도를 아끼기 위해서 구축하기에는 비용이 꽤 높다.
      - webhook 은 조금 더 범용적인 목적의 이벤트 감지를 위해 지원되는 기술같다. 특정 branch 의 push 만 감지하는 것을 지원하지 않는  듯.
      - github action 을 사용할 수 있다.
          - 직접 클라우드에 접속하는 권한을 주고, 스크립트로 빌드와 배포작업을 할 수 있으나, 클라우드에 Jenkins 등의 배포를 위한 서버를 따로 두는 것이 오히려 더 쉽다고 느꼈음.  

#### Jenkins 를 다루는 맥락
  - 머신의 최상위 레벨에 JDK 와 jenkins 등을 설치하는 것이 지저분하다고 느낄 수 있으므로, 컨테이너에 띄우고자 한다면, Jenkins 컨테이너 내부에서 머신의 최상위 레벨에 있는 Docker 컨텍스트를 조작할 수 있어야한다.
    - 이것을 위해서는 Docker outside of Docker.. 라는 식으로 불리는 소켓바인딩 기술을 사용하라고 권장되는 듯.
    - Jenkins 컨테이너 내부에서도 Docker CLI 는 사용할 수 있어야한다. 지금 시점에서는 [docker.io](http://docker.io) 를 설치하는것으로 해결보았다.
  - 이후의 작업에서 Jenkins 의 공식문서는 충분히 신뢰할 수 있는 듯.
  - 일본 프로그래머가 만들었다고 함.  
  
**Practice**  
도커로 젠킨스를 띄울시, 호스트 레벨의 도커와 소켓으로 바인딩하여 사용할수있다. `Docker outside of Docker` 라고 한다.
```
docker run -d --name jenkins --restart=on-failure \
-p 9000:8080 \
-v /var/jenkins_home:/var/jenkins_home \
-v /var/run/docker.sock:/var/run/docker.sock \
-e TZ=Asia/Seoul \
-u root \
jenkins/jenkins
```

이 경우, 젠킨스 컨테이너에서도 docker cli 는 필요하다.(docker.io 를 설치하여 해결가능)

appleboy/jenkins-action 을 사용하면 원격에서 쉽게 트리거할수있다.
`curl -X POST http://192.168.0.1:9000/job/AppName/build --user greennarae:11087e98dece7fb5a3516735899ec0e910`
API Token 은 jenkins-profile-API Token 에 있는것을 사용한다.

작업 생성 시, `Free Style Project`가 아닌, `Pipeline` 을 사용하도록 하자. 자유롭게 스크립트를 작성할 수 있다.

pipeline 스크립트 예제
pipeline {
	agent any
	
	environment {
		GIT_URL = "https://ghp_ABCDEFGABCDEFG@github.com/GreenNarae/SomeRepository.git"
	}


	stages {
		stage('Pull') {
			steps {
				git url: "${GIT_URL}", branch: "main", poll: true, changelog: true
			}
		}
		
		
		stage('Build') {
			steps {
				sh 'docker build -t Name .'
			}
		}
		
		stage('Deploy') {
			steps{
				sh 'docker ps -q --filter name=Name | grep -q . && docker stop Name && docker rm Name'
				sh 'docker run --name Name -d -p 8000:8000 -it --privileged --network=host ImageName'
			}
		}

	   stage('Finish') {
			steps{
				sh 'docker images -qf dangling=true | xargs -I{} docker rmi {}'
			}
		}
	}
}

---  






