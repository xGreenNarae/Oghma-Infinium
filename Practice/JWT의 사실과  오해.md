배경은,
나는 "웹 개발", "백엔드" 같은 것을 공부하기 시작할 때, 구글 검색을 통해서 블로그 글이나 유명한 유튜브의 튜토리얼 같은 것을 보고 시작했다. 프레임워크도 Flask, Django, Nestjs 등 다양하게 있는데 ..
단골로 등장하는 코스가 "JWT로 회원가입/로그인 구현하기" 이다.

처음엔 그냥 따라하는 것이니까, 왜 이것을 사용하는지에 대한 의문은 없다. 그런데 아마 지금 생각해보면 이 속에는 인증/인가를 구현하는 방법들이 발전해온 역사 같은 것들이 녹아있을 것이다..

그러다 보면 발생하는 첫 번째 오해는 **"JWT는 인증/인가를 구현하는 Best Practice 정도 이다."** 라는 생각을 갖게 되는 것인데, 틀린 이야기라고 할 수는 없겠지만 함정은 JWT가 어떤 장점을 가지는지에 대한 오해가 발생할 수 있다는 것 같다.

보안에 관한 개념이나 프로토콜들이 다루는 많은 내용들은 핵심인 "기밀성", "무결성" 등을 보장하는 기능적 원리보다는 **"어떤 정보들을 어떻게 담을 것인가"** 에 치중되어 있는 듯 하고.. JWT도 그런 관점에서 클레임이라고 부르는 "iss", "sub", "exp" ... 등의 표준에 명시된 권한을 잘 나누고 관리할 수 있는 프로토콜 정도가 의미를 갖는 내용인듯 하다.
오히려 인증/인가 자체를 처음 공부하고 있는 내가 집중해야 했던, 실제로 필요했던 것은 **"기밀성", "무결성" 등을 보장하는 기능적 원리** 인데, JWT라고 부르는 개념은 이것과 딱히 직접적인 관련이 없다.

```
기밀성과 무결성

기밀성: 전달하는 메시지 내용을 이해관계자가 아닌 외부인이 확인할 수 없는 것.

무결성: 메시지 내용이 변조되지 않았다는 사실을 보장할 수 있는 것.
```

흔한 예제들을 기준 삼아보면.. (HMACSHA 256 등을 사용하는..)
이 관점에서 중요한 것은 단지 **MAC(Message Authentication Code) + base64URLEncoding** 뿐이다.
```
MAC은 메시지의 무결성을 보장하는 Signature(서류에 사인할 때 그것) 정도로, 단방향 해시 함수 등으로 구현할 수 있다.
```
MAC이 중요한 것은, "기밀성"이 필요하지 않는 경우에 **메시지 전체를 암호화하는 것 보다, 성능 상 유리하다** 는 것이다.

다음으로는 JWT 이전에 인증/인가를 구현하던 흔한 practice들은 "세션 방식" 이라고 부르는, 인증 정보를 서버에서 (주로 메모리) 저장하여 운용하던 것으로 추측하는데.. JWT는 stateless 한 방식을 사용하여 **"많은 사용자의 인증을 처리하는 경우에도 서버 부하로 부터 유연하다"** 이고, 다시 반복하자면 이것은 **JWT 이기 때문에 갖는 장점은 아니다.** MAC을 통해 "무결성"을 보장할 수 있는 데이터를 브라우저의 쿠키 등에 넣어 놓고 사용하는 것이 본질이다.

여기까지가 JWT에 대한 사실과 오해.
JSON이라는 점이 편리한 부분도 있을 것 이다.
[JWT RFC 숫자 무엇무엇 링크](https://datatracker.ietf.org/doc/html/rfc7519#appendix-C)


그 다음은 Refresh Token 에 대한 사실과 오해다.
위의 흐름에 따라가다 보면 블로그 등을 통해 Refresh Token 이라는 키워드에 도달하게 되는데, 대략 공통적인 이야기들을 하고 있고 요약하자면 다음과 같다.
**"액세스 토큰이 탈취되면 Revoke할 방법이 없으므로, 만료기한이 긴 Refresh Token을 추가로 발급하고, 액세스토큰은 만료기한을 짧게두어 보안을 강화할 수 있다."**
굉장히 이상한 이야기다. 그냥 이대로 끝나는 글 들도 많고, 이 이상한 포인트를 짚어내며 의심하고 토론하다가 결론 없이 마무리되는 글 들도 많다.

일단 이 개념도 구현에 대한 내용이 아닌, [표준](https://www.rfc-editor.org/rfc/rfc6749#section-1.4)이 우선 되는 것인데,
표준에서는 분명히 
1. 서버 측 상태관리
2.  [로테이션](https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation)
3.  IP등 클라이언트의 속성과 바인딩
4. 리소스서버와 인증서버의 분리… 
등의 추가적인 컨트롤을 요구하고 있다.

이 중에 흔한 예제들은 "서버 측 상태관리" 정도를 구현하고 있는데, **DB에 User에게 발급된 Refresh Token 정보를 저장하고, Access Token 재 발급 요청 시 이 값과 비교하여 검증한다**라는 구현체..
문제는, 기존에 사용하던 세션 방식의 인증 정보 관리가 사용하던 stateful 한 구현으로 회귀해버린 것이 아닌가 하는 것이다.

또한 탈취에 대한 이야기로는, Refresh Token이 탈취 되는 것에 대해서는 어떻게 할 것인가인데, 이 부분은 서버 구현과 무관하게 클라이언트 이야기로 넘어간다.
`Http Only Cookie`를 사용하면, `document.cookie` 등의 JS코드로 접근할 수 없다는 점(xss 방지), `Secure Cookie`를 사용하면 `https` 가 아닌 주소로는 전송하지 않는다는 점(도감청 방지) 등의 이야기들이 나온다. 말 그대로 브라우저가 쿠키를 안전하게 보관하기 위한 노력의 이야기일 뿐 이다.
표준은 딱히 무엇도 강제하지 않는다. 클라이언트에 Refresh Token자체를 주지 않고, 별도의 인증 서버에 code를 통해서만 접근할 수 있게 한다는 등의 이야기도 있는데 이런건 다시 OAuth 이야기다.

다시 위에서 이야기하는 4번 "리소스 서버와 인증 서버의 분리" 의 경우에는 의미를 갖게 되는 듯  하다. 복잡하게 얽힌 많은 서버들 사이에서 인증 서버를 별도로 두고 처리해야하는 상황에서 여러가지 작업들이 필요한데, 이 단계에서는 꼭 Refresh Token 표준이 아니더라도 다양한 무언가를  해야하는 상황이라는 것. 오히려 이미 발급된 Token을 Revoke 해야하는 상황을 파악할 수 있는 다양한 처리(평소와 다른 IP로의 요청 등..) 등이 우선되어야 할 듯 하다..

결론, 그래서 어떻게 하는 것이 바람직한가 ?
최대한 빠르고 간결하게 인증/인가를 구현하려는 상황이라면 (실 사용자가 없는 토이프로젝트라거나 기초 구현을 하는 초기 MVP 작업이라거나..) **해시함수를 이용한 MAC을 담은 정보를 클라이언트(브라우저 쿠키 등)에 저장하고 쓴다.** JWT가 더 간단하고 편리하다면 JWT를 쓴다.
보안을 더 신경써야 한다면 서버에서 인증 정보를 운용하는 **Session 방식**의 구현을 한다.
