이것이 필요한 이유
  - 클라이언트 작업을 하는 사람이 분리되어 있는 경우, 작업 중인 서버의 최신 상태를 로컬이 아닌 원격에 두는 것이 편리하다.
  - `깃허브의 메인 브랜치 소스코드가 변경된 시점부터` 공개적으로 접근할 수 있는 `원격 서버의 코드를 갱신해주기 까지`의 작업을 자동화 하는 것.  
  
이 영역을 자동화 하는 방법은 내가 경험해 본것을 바탕으로 3가지 레벨로 나눌 수 있다.
  1. 수동작업:  로컬 터미널에서 클라우드에 접속하여, 레포지토리를 클론하고, 기존의 코드를 교체한 뒤, 서비스 중인 프로세스를 종료하고 새 것을 띄운다. 간단한 규모에서 능숙하더라도 3분 정도는 소요될 것이고 실수할 여지도 많다.
  2. 스크립트 작성: 클라우드 접속, 소스코드를 내려받고 교체하는 작업 등을 스크립트로 자동화한다. 빨라도 10초 정도는 소요된다.
  3. 깃허브에서 이벤트가 발생했을 시 자동으로 작업을 트리거해주는 기술을 지원한다. webhook, github actions 등 인데, 
      - 작업 당 10초 정도를 아끼기 위해서 구축하기에는 비용이 꽤 높다.
      - webhook 은 조금 더 범용적인 목적의 이벤트 감지를 위해 지원되는 기술같다. 특정 branch 의 push 만 감지하는 것을 지원하지 않는  듯.
      - github action 을 사용할 수 있다.
          - 직접 클라우드에 접속하는 권한을 주고, 스크립트로 빌드와 배포작업을 할 수 있으나, 클라우드에 Jenkins 등의 배포를 위한 서버를 따로 두는 것이 오히려 더 쉽다고 느꼈음.  

**GitHub Actions vs Jenkins**
배포 자동화에 Jenkins 등의 별도 서버를 사용할 것인가 하는 이야기.

**GitHub Actions**만 사용한다면
시크릿들은 GitHub Secrets 또는 Variables 등으로 저장하고, ssh로 원격서버에 직접 접속하여 실행하는 모든 스크립트들을 GitHub Actions Job으로 해결하는 방식이다.
가장 큰 장점은 빌드와 배포 관련 작업의 **관리포인트가 GitHub Actions 한 곳**으로 모인다는 점이다.

**Jenkins**를 사용하면 더 풍부한 기능을 활용 할 수 있다.
- **이전 작업 기록, 평균 작업 시간** 등을 확인하거나..
- GitHub Repository를 건드리지 않고 **polling**하는 방법으로 자동배포를 구현할 수도 있다.(필요할지는 별개의 문제)
- 짧은 주기에 연속적으로 PR merge가 발생하는 등, 서버에서 이미 배포 작업이 진행 중인 상황에, 새로운 작업이 실행되려는 경우, Jenkins를 사용한다면 **새 작업을 동시 진행하지 않고 대기열에 포함해두거나, 진행 중이던 예전 작업을 버리고 최신 작업을 실행**하는 등이 가능하다.


