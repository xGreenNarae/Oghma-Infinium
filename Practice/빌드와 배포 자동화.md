이것이 필요한 이유
  - 클라이언트 작업을 하는 사람이 분리되어 있는 경우, 작업 중인 서버의 최신 상태를 로컬이 아닌 원격에 두는 것이 편리하다.
  - `깃허브의 메인 브랜치 소스코드가 변경된 시점부터` 공개적으로 접근할 수 있는 `원격 서버의 코드를 갱신해주기 까지`의 작업을 자동화 하는 것.  
  
이 영역을 자동화 하는 방법은 내가 경험해 본것을 바탕으로 3가지 레벨로 나눌 수 있다.
  1. 수동작업:  로컬 터미널에서 클라우드에 접속하여, 레포지토리를 클론하고, 기존의 코드를 교체한 뒤, 서비스 중인 프로세스를 종료하고 새 것을 띄운다. 간단한 규모에서 능숙하더라도 3분 정도는 소요될 것이고 실수할 여지도 많다.
  2. 스크립트 작성: 클라우드 접속, 소스코드를 내려받고 교체하는 작업 등을 스크립트로 자동화한다. 빨라도 10초 정도는 소요된다.
  3. 깃허브에서 이벤트가 발생했을 시 자동으로 작업을 트리거해주는 기술을 지원한다. webhook, github actions 등 인데, 
      - 작업 당 10초 정도를 아끼기 위해서 구축하기에는 비용이 꽤 높다.
      - webhook 은 조금 더 범용적인 목적의 이벤트 감지를 위해 지원되는 기술같다. 특정 branch 의 push 만 감지하는 것을 지원하지 않는  듯.
      - github action 을 사용할 수 있다.
          - 직접 클라우드에 접속하는 권한을 주고, 스크립트로 빌드와 배포작업을 할 수 있으나, 클라우드에 Jenkins 등의 배포를 위한 서버를 따로 두는 것이 오히려 더 쉽다고 느꼈음.  

Jenkins 를 다루는 맥락
  - 머신의 최상위 레벨에 JDK 와 jenkins 등을 설치하는 것이 지저분하다고 느낄 수 있으므로, 컨테이너에 띄우고자 한다면, Jenkins 컨테이너 내부에서 머신의 최상위 레벨에 있는 Docker 컨텍스트를 조작할 수 있어야한다.
    - 이것을 위해서는 Docker outside of Docker.. 라는 식으로 불리는 소켓바인딩 기술을 사용하라고 권장되는 듯.
    - Jenkins 컨테이너 내부에서도 Docker CLI 는 사용할 수 있어야한다. 지금 시점에서는 [docker.io](http://docker.io) 를 설치하는것으로 해결보았다.
  - 이후의 작업에서 Jenkins 의 공식문서는 충분히 신뢰할 수 있는 듯.
  - 일본 프로그래머가 만들었다고 함.